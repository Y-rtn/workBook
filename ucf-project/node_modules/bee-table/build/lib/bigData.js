"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.bigDataOld = bigDataOld;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = require("./utils");

var _bigDataX = require("./bigDataX");

var _bigDataX2 = _interopRequireDefault(_bigDataX);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var defaultHeight = 30; //缺省的默认行高
var defaultLoadCount = 26; //缺省的每次加载行个数
var rowDiff = 2; //行差值
var treeTypeIndex = 0;
exports["default"] = _bigDataX2["default"]; //新重构版的bigDataX

function bigDataOld(Table) {
  var _class, _temp, _initialiseProps;

  //暂时保留旧版本的bigData，旧版仅ncc在用
  console.warn('旧版bigData，建议使用bigDataX');
  return _temp = _class = function (_Component) {
    _inherits(BigData, _Component);

    function BigData(props) {
      _classCallCheck(this, BigData);

      var _this2 = _possibleConstructorReturn(this, _Component.call(this, props));

      _initialiseProps.call(_this2);

      _this2.state = {
        scrollLeft: 0,
        scrollTop: 0
      };
      //每行默认高度
      var rowHeight = _this2.props.height ? _this2.props.height : defaultHeight;
      //默认可视区域高度
      var scrollY = _this2.props.scroll.y ? parseInt(_this2.props.scroll.y) : 0;
      //计算出显示到可视区域的行数
      _this2.rowsInView = scrollY ? Math.floor(scrollY / rowHeight) : 20;
      _this2.currentIndex = 0;
      //一次加载的数据行数（包含缓存的数据行）
      _this2.loadCount = props.loadBuffer ? _this2.rowsInView + props.loadBuffer * 2 : defaultLoadCount;
      _this2.cachedRowHeight = []; //缓存每行的高度
      _this2.cachedRowParentIndex = [];
      _this2.expandChildRowKeys = [];
      _this2.firstLevelKey = [];
      _this2.keys = [];
      _this2.lastScrollTop = 0;
      _this2.currentScrollTop = 0;
      _this2.startIndex = _this2.currentIndex; //数据开始位置
      _this2.endIndex = _this2.currentIndex + _this2.loadCount; //数据结束位置
      _this2.setRowHeight = _this2.setRowHeight.bind(_this2);
      _this2.setRowParentIndex = _this2.setRowParentIndex.bind(_this2);
      _this2.expandedRowKeys = props.expandedRowKeys || [];
      _this2.flatTreeKeysMap = {}; //树表，扁平结构数据的 Map 映射，方便获取各节点信息
      _this2.flatTreeData = []; //深度遍历处理后的data数组
      _this2.treeData = []; //树表的data数据
      return _this2;
    }

    BigData.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
      var props = this.props;
      var currentIndex = nextProps.currentIndex,
          newExpandedKeys = nextProps.expandedRowKeys,
          newData = nextProps.data;

      var _this = this;
      var dataLen = newData.length;
      if ('isTree' in nextProps || 'data' in nextProps) {
        _this.treeType = _this.checkIsTreeType(nextProps.isTree, nextProps.data);
      }
      // 可视滚动区域变化时
      if ('scroll' in nextProps && nextProps.scroll.y !== props.scroll.y) {
        //每行默认高度
        var rowHeight = nextProps.height ? nextProps.height : defaultHeight;
        //默认可视区域高度
        var scrollY = nextProps.scroll.y ? parseInt(nextProps.scroll.y) : 0;
        //显示在可视区域的行数
        _this.rowsInView = scrollY ? Math.floor(scrollY / rowHeight) : 20;
        //一次加载的数据行数（包含缓存的数据行）
        _this.loadCount = props.loadBuffer ? _this.rowsInView + props.loadBuffer * 2 : defaultLoadCount; //一次加载多少数据
        _this.currentIndex = 0;
        _this.startIndex = _this.currentIndex; //数据开始位置
        _this.endIndex = _this.currentIndex + _this.loadCount; //数据结束位置
      }
      if ('data' in nextProps) {
        //fix: 滚动加载场景中,数据动态改变下占位计算错误的问题(26 Jun)
        if (newData.toString() !== props.data.toString()) {
          // console.log("AAA----1--->nextProps.currentIndex"+nextProps.currentIndex+"-->scrollTop:"+_this.state.scrollTop);
          _this.cachedRowHeight = []; //缓存每行的高度
          _this.cachedRowParentIndex = [];
          _this.computeCachedRowParentIndex(newData, _this.treeType);
          // fix：切换数据源，startIndex、endIndex错误
          if (_this.state.scrollTop <= 0) {
            // 增加scrollTop 判断，ncc场景下滚动条不在最上层， 会出现空白，因为重置了currentIndex没有重置滚动条
            _this.currentIndex = 0;
            _this.startIndex = _this.currentIndex; //数据开始位置
            _this.endIndex = _this.currentIndex + _this.loadCount;
          }
        }
        _this.treeData = [];
        _this.flatTreeData = [];
        // if(newData.length>0){
        //   _this.endIndex = _this.currentIndex - nextProps.loadBuffer + _this.loadCount; //数据结束位置
        // }
        if (_this.treeType) {
          _this.getTreeData(newExpandedKeys, newData);
          dataLen = _this.flatTreeData.length; //更新数据量 add by qianfan
        }
      }
      //如果传currentIndex，会判断该条数据是否在可视区域，如果没有的话，则重新计算startIndex和endIndex
      if (currentIndex != -1) {
        // 考虑缓存数据情况去掉currentIndex !== this.currentIndex条件
        var preCurrentIndex = this.props.currentIndex === -1 ? this.preCurrentIndex : this.props.currentIndex; // 传入上一次的currentIndex，用以判断向上滑动还是向下滑动，以区分上下缓存区
        _this.setStartAndEndIndex(currentIndex, preCurrentIndex, dataLen);
      } else {
        // 如果currentIndex传-1，存储上次currentIndex
        this.preCurrentIndex = this.props.currentIndex;
      }
      if (_this.treeType) {
        //按计算后的位置截取数据
        var sliceTreeList = _this.flatTreeData.slice(_this.startIndex, _this.endIndex + 1); // +1为解决currentIndex计算定位，从新计算表格接受的数据包括this.endIndex（最后一条）数据
        this.handleTreeListChange(sliceTreeList);
      }
    };

    BigData.prototype.componentWillMount = function componentWillMount() {
      var _props = this.props,
          isTree = _props.isTree,
          expandedRowKeys = _props.expandedRowKeys,
          data = _props.data;

      var isTreeType = this.checkIsTreeType(isTree, data);
      //设置data中每个元素的parentIndex
      this.computeCachedRowParentIndex(data, isTreeType);
      //如果是树表，递归data
      if (isTreeType) {
        this.treeType = isTreeType;
        this.getTreeData(expandedRowKeys, data);
      }
    };

    /**
     * 如果是树形表，需要对传入的 data 进行处理
     * @param expandedKeys: nextProps 中传入的新 expandedRowKeys 属性值
     * @param newData: nextProps 中传入的新 data 属性值
     */


    /**
     * 深度遍历树形 data，把数据拍平，变为一维数组
     * @param {*} data
     * @param {*} parentKey 标识父节点
     */


    /**
     * 将截取后的 List 数组转换为 Tree 结构，并更新 state
     */


    /**
     *设置data中每个元素的parentIndex
     *
     */


    //为外部定位currentIndex提供支持，以确保currentIndex行显示在可视区域
    BigData.prototype.setStartAndEndIndex = function setStartAndEndIndex(currentIndex, preCurrentIndex, dataLen) {
      var _this = this;
      if (currentIndex < 0) currentIndex = 0;
      if (currentIndex + 1 >= dataLen) currentIndex = dataLen; //确保当前索引不超过记录总数索引
      var newScrollTop = this.state.scrollTop;
      if (currentIndex >= _this.endIndex) {
        //新位置超过原来底部
        _this.endIndex = currentIndex; //数据底部位置
        _this.startIndex = _this.endIndex - _this.loadCount; //数据结束位置
        _this.currentIndex = this.endIndex - this.rowsInView;
        //重新设定scrollTop值
        newScrollTop = _this.getSumHeight(0, _this.currentIndex + 1);
      } else if (currentIndex <= _this.startIndex) {
        //新位置超过原来顶部
        _this.currentIndex = currentIndex;
        _this.startIndex = currentIndex;
        _this.endIndex = currentIndex + _this.loadCount;
        //重新设定scrollTop值
        newScrollTop = _this.getSumHeight(0, _this.currentIndex);
      } else if (_this.startIndex + this.rowsInView <= currentIndex && currentIndex <= _this.endIndex && currentIndex > preCurrentIndex) {
        // currentIndex在可视区和缓存区底部之间
        _this.currentIndex = currentIndex - this.rowsInView;
        //重新设定scrollTop值
        newScrollTop = _this.getSumHeight(0, _this.currentIndex + 1);
      } else if (currentIndex >= _this.startIndex && currentIndex <= _this.endIndex - this.rowsInView && currentIndex < preCurrentIndex) {
        _this.currentIndex = currentIndex;
        //重新设定scrollTop值
        newScrollTop = _this.getSumHeight(0, _this.currentIndex);
      }
      if (newScrollTop !== this.state.scrollTop) {
        this.setState({ scrollTop: newScrollTop });
      }
    };

    //获取每行的唯一键


    BigData.prototype.getRowKey = function getRowKey(record, index) {
      var rowKey = this.props.rowKey;
      var key = typeof rowKey === "function" ? rowKey(record, index) : record[rowKey];

      return key;
    };
    /**
     *判断是否是树形结构
     *
     */


    BigData.prototype.checkIsTreeType = function checkIsTreeType(isTree, data) {
      if (typeof isTree == 'boolean') return isTree;
      var len = (data || []).length;
      //看是否有children属性，有则为树形结构
      for (var i = 0; i < len; i++) {
        if (data[i].children !== undefined) {
          return true;
        }
      }
      return false;
    };

    BigData.prototype.getData = function getData(data, parentIndex) {
      var _this3 = this;

      data.forEach(function (subItem, subIndex) {
        _this3.cachedRowParentIndex[treeTypeIndex] = parentIndex;
        _this3.keys[treeTypeIndex] = _this3.getRowKey(subItem, subIndex);
        treeTypeIndex++;
        if (subItem.children) {
          _this3.getData(subItem.children, parentIndex);
        }
      });
    };

    BigData.prototype.componentWillUnmount = function componentWillUnmount() {
      this.cachedRowHeight = [];
      this.cachedRowParentIndex = [];
    };
    /**
     *获取数据区高度
     *
     *
     **/


    BigData.prototype.getContentHeight = function getContentHeight() {
      if (!this.props.data) return 0;
      return this.getSumHeight(0, this.props.data.length);
    };
    //计算总行高


    BigData.prototype.getSumHeight = function getSumHeight(start, end) {
      var height = this.props.height;

      var rowHeight = height ? height : defaultHeight;
      var sumHeight = 0,
          currentKey = void 0,
          currentRowHeight = rowHeight;

      for (var i = start; i < end; i++) {
        if (this.cachedRowHeight[i] == undefined) {
          if (this.treeType) {
            // currentKey = this.keys[i];
            currentKey = this.flatTreeData[i] && this.flatTreeData[i].key;
            currentRowHeight = 0;
            if (this.flatTreeKeysMap.hasOwnProperty(currentKey)) {
              currentRowHeight = rowHeight;
            }
          }
          sumHeight += currentRowHeight;
        } else {
          sumHeight += this.cachedRowHeight[i];
        }
      }
      return sumHeight;
    };
    //表格尺寸变化时，重新计算滚动及显示位置

    /**
     *@description  根据返回的scrollTop计算当前的索引。此处做了两次缓存一个是根据上一次的currentIndex计算当前currentIndex。另一个是根据当前内容区的数据是否在缓存中如果在则不重新render页面
     *@param 最新一次滚动的scrollTop
     *@param treeType是否是树状表
     *@param callback表体滚动过程中触发的回调
     */


    BigData.prototype.setRowHeight = function setRowHeight(height, index) {
      this.cachedRowHeight[index] = height;
    };

    BigData.prototype.setRowParentIndex = function setRowParentIndex(parentIndex, index) {}
    // this.cachedRowParentIndex[index] = parentIndex;

    /**
     *
     *根据当前行号获取该行的父节点行号
     * @param {*} currentIndex 当前行号
     */
    ;

    BigData.prototype.getParentIndex = function getParentIndex(targetIndex) {
      var data = this.props.data;

      var parentIndex = -1;
      parentIndex = this.getIndex(data, -1, targetIndex);
      if (parentIndex < 0) {
        //小于0说明没有展开的子节点
        parentIndex = targetIndex;
      }
      return parentIndex;
    };

    BigData.prototype.getIndex = function getIndex(data, index, targetIndex) {
      var parentIndex = index;
      for (var i = 0; i < data.length; i++) {
        index++;
        if (targetIndex <= index) {
          break;
        }
        if (data[i].children) {
          this.getIndex(data[i].children, index, targetIndex);
        }
      }
      return parentIndex;
    };

    BigData.prototype.render = function render() {
      var _this4 = this;

      var data = this.props.data;
      var scrollTop = this.state.scrollTop;
      var endIndex = this.endIndex,
          startIndex = this.startIndex,
          treeData = this.treeData,
          treeType = this.treeType,
          flatTreeData = this.flatTreeData;

      var expandedRowKeys = this.props.expandedRowKeys ? this.props.expandedRowKeys : this.expandedRowKeys;
      if (startIndex < 0) {
        startIndex = 0;
      }
      if (endIndex < 0) {
        endIndex = 0;
      }
      //树表类型时
      if (treeType && endIndex > flatTreeData.length || !treeType && endIndex > data.length) {
        endIndex = treeType ? flatTreeData.length : data.length;
      }
      var lazyLoad = {
        startIndex: startIndex,
        endIndex: endIndex,
        startParentIndex: startIndex //为树状节点做准备
      };
      if (treeType) {
        lazyLoad.preHeight = this.getSumHeight(0, startIndex);
        lazyLoad.sufHeight = this.getSumHeight(endIndex, flatTreeData.length);
      } else {
        lazyLoad.preHeight = this.getSumHeight(0, startIndex);
        lazyLoad.sufHeight = this.getSumHeight(endIndex, data.length);
      }
      // console.log("AAA--->startIndex:"+startIndex+"--->endIndex:"+endIndex+"--->currentIndex:"+this.currentIndex+"-->scrollTop:"+scrollTop);
      // console.log('*******expandedRowKeys*****'+expandedRowKeys);
      var dataSource = treeType && Array.isArray(treeData) && treeData.length > 0 ? treeData : data.slice(startIndex, endIndex + 1);
      return _react2["default"].createElement(Table, _extends({}, this.props, {
        data: dataSource,
        lazyLoad: lazyLoad,
        ref: function ref(el) {
          return _this4.table = el;
        },
        handleScrollY: this.handleScrollY,
        scrollTop: scrollTop,
        setRowHeight: this.setRowHeight,
        setRowParentIndex: this.setRowParentIndex,
        onResize: this.handleResize,
        onExpand: this.onExpand,
        onExpandedRowsChange: this.props.onExpandedRowsChange,
        expandedRowKeys: expandedRowKeys
        //   className={'lazy-table'}
      }));
    };

    return BigData;
  }(_react.Component), _class.defaultProps = {
    data: [],
    loadBuffer: 20,
    rowKey: "key",
    onExpand: function onExpand() {},

    scroll: {},
    currentIndex: -1,
    isTree: null
  }, _class.propTypes = {
    loadBuffer: _propTypes2["default"].number,
    height: _propTypes2["default"].number,
    scroll: _propTypes2["default"].any,
    expandedRowKeys: _propTypes2["default"].string,
    rowKey: _propTypes2["default"].string,
    nextContext: _propTypes2["default"].any,
    currentIndex: _propTypes2["default"].number,
    isTree: _propTypes2["default"].bool,
    data: _propTypes2["default"].any,
    onExpandedRowsChange: _propTypes2["default"].func
  }, _initialiseProps = function _initialiseProps() {
    var _this5 = this;

    this.getTreeData = function (expandedKeys, newData) {
      var startIndex = _this5.startIndex,
          endIndex = _this5.endIndex;

      _this5.cacheExpandedKeys = expandedKeys && new Set(expandedKeys);
      // 深递归 data，截取可视区 data 数组，再将扁平结构转换成嵌套结构
      var sliceTreeList = [];
      var flatTreeData = _this5.deepTraversal(newData);
      _this5.flatTreeData = flatTreeData;
      sliceTreeList = flatTreeData.slice(startIndex, endIndex);
      _this5.handleTreeListChange(sliceTreeList);

      _this5.cacheExpandedKeys = expandedKeys && null;
    };

    this.deepTraversal = function (treeData) {
      var parentKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _this = _this5;
      var cacheExpandedKeys = _this.cacheExpandedKeys,
          _this$expandedRowKeys = _this.expandedRowKeys,
          expandedRowKeys = _this$expandedRowKeys === undefined ? [] : _this$expandedRowKeys,
          flatTreeKeysMap = _this.flatTreeKeysMap,
          expandedKeysSet = cacheExpandedKeys ? cacheExpandedKeys : new Set(expandedRowKeys),
          flatTreeData = [],
          dataCopy = treeData;

      if (Array.isArray(dataCopy)) {
        for (var i = 0, l = dataCopy.length; i < l; i++) {
          var _dataCopy$i = dataCopy[i],
              children = _dataCopy$i.children,
              props = _objectWithoutProperties(_dataCopy$i, ["children"]),
              key = _this5.getRowKey(dataCopy[i], i),
              dataCopyI = new Object(),
              _isLeaf = children && children.length > 0 ? false : true,
              isExpanded = parentKey === null || expandedKeysSet.has(parentKey) ? expandedKeysSet.has(key) : false;

          dataCopyI = _extends(dataCopyI, {
            key: key,
            isExpanded: isExpanded,
            parentKey: parentKey,
            _isLeaf: _isLeaf,
            index: flatTreeData.length
          }, _extends({}, props));

          flatTreeData.push(dataCopyI); // 取每项数据放入一个新数组
          flatTreeKeysMap[key] = dataCopyI;

          // 优化递归逻辑，如果当前节点是收起状态，则不遍历其子节点
          if (Array.isArray(children) && children.length > 0 && isExpanded) {
            flatTreeData = flatTreeData.concat(_this5.deepTraversal(children, key));
          }
        }
      }
      return flatTreeData;
    };

    this.handleTreeListChange = function (treeList, startIndex, endIndex) {
      // 属性配置设置
      var attr = {
        id: 'key',
        parendId: 'parentKey',
        rootId: null,
        _isLeaf: '_isLeaf'
      };
      var treeData = (0, _utils.convertListToTree)(treeList, attr, _this5.flatTreeKeysMap);

      _this5.startIndex = typeof startIndex !== "undefined" ? startIndex : _this5.startIndex;
      _this5.endIndex = typeof endIndex !== "undefined" ? endIndex : _this5.endIndex;

      _this5.treeData = treeData;
    };

    this.computeCachedRowParentIndex = function (data, isTreeType) {
      var treeTypeIndex = 0;
      if (isTreeType) {
        data.forEach(function (item, index) {
          _this5.firstLevelKey[index] = _this5.getRowKey(item, index);
          _this5.cachedRowParentIndex[treeTypeIndex] = index;
          //保存所有的keys跟小标对应起来
          _this5.keys[treeTypeIndex] = _this5.getRowKey(item, index);
          treeTypeIndex++;
          if (item.children) {
            _this5.getData(item.children, index);
          }
        });
      }
    };

    this.handleResize = function () {
      _this5.handleScrollY(_this5.state.scrollTop, _this5.treeType);
    };

    this.handleScrollY = function (nextScrollTop, treeType, callback) {
      //树表逻辑
      // 关键点是动态的获取startIndex和endIndex
      // 法子一：子节点也看成普通tr，最开始需要设置一共有多少行，哪行显示哪行不显示如何确定
      // 动态取start = current+buffer对应的父节点、end = start+loadCount+row的height为0的行数 展开节点的下一个节点作为end值，
      var _this = _this5;
      var _this$props = _this.props,
          data = _this$props.data,
          height = _this$props.height,
          _this$props$scroll = _this$props.scroll,
          scroll = _this$props$scroll === undefined ? {} : _this$props$scroll,
          loadBuffer = _this$props.loadBuffer;

      var rowHeight = height ? height : defaultHeight;
      var _this$currentIndex = _this.currentIndex,
          currentIndex = _this$currentIndex === undefined ? 0 : _this$currentIndex,
          loadCount = _this.loadCount,
          currentScrollTop = _this.currentScrollTop,
          flatTreeData = _this.flatTreeData;
      var endIndex = _this.endIndex,
          startIndex = _this.startIndex;
      var needRender = _this.state.needRender;

      _this.setState({ scrollTop: nextScrollTop });
      var viewHeight = parseInt(scroll.y);
      _this.treeType = treeType;
      var index = 0;
      var temp = nextScrollTop;
      var currentKey = void 0;
      while (temp > 0) {
        var currentRowHeight = _this5.cachedRowHeight[index];
        if (currentRowHeight === undefined) {
          if (_this5.treeType) {
            // currentKey = this.keys[index];
            currentKey = _this5.flatTreeData[index].key;
            currentRowHeight = 0;
            if (_this5.flatTreeKeysMap.hasOwnProperty(currentKey)) {
              currentRowHeight = rowHeight;
            }
          } else {
            currentRowHeight = rowHeight;
          }
        }
        temp -= currentRowHeight;
        if (temp > 0) {
          index += 1;
        }
      }
      // console.log('currentIndex****',index);
      var isOrder = index - currentIndex > 0 ? true : false;
      if (index < 0) index = 0;
      //如果之前的索引和下一次的不一样则重置索引和滚动的位置
      if (currentIndex !== index) {
        _this.currentIndex = index;
        var rowsInView = 0; //可视区域显示多少行
        var rowsHeight = 0; //可视区域内容高度
        var tempIndex = index;
        //如果可视区域中需要展示的数据已经在缓存中则不重现render。
        if (viewHeight) {
          //有时滚动过快时this.cachedRowHeight[rowsInView + index]为undifined

          while (rowsHeight < viewHeight && tempIndex < _this5.cachedRowHeight.length) {
            if (_this5.cachedRowHeight[tempIndex]) {
              rowsHeight += _this5.cachedRowHeight[tempIndex];
              // if (
              //   (treeType &&
              //     _this.cachedRowParentIndex[tempIndex] !== tempIndex) ||
              //   !treeType
              // ) {
              rowsInView++;
              // }
            }
            tempIndex++;
          }
          // if (treeType) {
          //   const treeIndex = index;
          //   index = _this.cachedRowParentIndex[treeIndex];
          //   if (index === undefined) {
          //     // console.log('index is undefined********'+treeIndex);
          //     index = this.getParentIndex(treeIndex);
          //     // console.log("getParentIndex****"+index);
          //   }
          // }
          // console.log('parentIndex*********',index);
          // 如果rowsInView 小于 缓存的数据则重新render
          // 向下滚动 下临界值超出缓存的endIndex则重新渲染
          if (rowsInView + index > endIndex - loadBuffer && isOrder) {
            startIndex = index - loadBuffer > 0 ? index - loadBuffer : 0;
            // endIndex = startIndex + rowsInView + loadBuffer*2;
            endIndex = startIndex + loadCount;
            if (treeType && endIndex > flatTreeData.length || !treeType && endIndex > data.length) {
              endIndex = treeType ? flatTreeData.length : data.length;
            }
            if (endIndex > _this5.endIndex) {
              _this5.startIndex = startIndex;
              _this5.endIndex = endIndex;
              if (treeType) {
                _this5.handleTreeListChange(flatTreeData.slice(startIndex, endIndex), startIndex, endIndex);
              }
              _this5.setState({ needRender: !needRender });
              callback && callback(parseInt(currentIndex + rowsInView));
            }
          }
          // 向上滚动，当前的index是否已经加载（currentIndex），若干上临界值小于startIndex则重新渲染
          if (!isOrder && index < startIndex + loadBuffer) {
            startIndex = index - loadBuffer;
            if (startIndex < 0) {
              startIndex = 0;
            }
            if (startIndex < _this5.startIndex) {
              _this5.startIndex = startIndex;
              _this5.endIndex = _this5.startIndex + loadCount;
              if (treeType) {
                _this5.handleTreeListChange(flatTreeData.slice(startIndex, _this5.endIndex), startIndex, _this5.endIndex);
              }
              _this5.setState({ needRender: !needRender });
              callback && callback(parseInt(currentIndex + rowsInView)); //返回可视区域的最后一条数据索引
            }
            // console.log(
            //   "**index**" + index,
            //   "**startIndex**" + this.startIndex,
            //   "**endIndex**" + this.endIndex
            // );
          }
        }
      }
    };

    this.onExpand = function (expandState, record, index) {
      var _this = _this5;
      var _this$expandedRowKeys2 = _this.expandedRowKeys,
          expandedRowKeys = _this$expandedRowKeys2 === undefined ? [] : _this$expandedRowKeys2;
      var needRender = _this.state.needRender;
      var data = _this.props.data;

      var rowKey = _this.getRowKey(record, index);
      // 记录展开子表行的key
      // 展开
      if (record.children) {
        if (expandState) {
          record.children.forEach(function (item, index) {
            _this.expandChildRowKeys.push(rowKey);
          });
        } else {
          // 收起
          record.children.forEach(function (item, index) {
            _this.expandChildRowKeys.splice(_this.expandChildRowKeys.findIndex(function (fitem) {
              return fitem.key === item.key;
            }), 1);
          });
        }
      }
      //滚动加载expandedRowKeys自己维护，否则有展开不全的问题
      if (!_this.props.expandedRowKeys) {
        if (expandState) {
          expandedRowKeys.push(rowKey);
          _this5.setState({ needRender: !needRender });
        } else {
          var _index = -1;
          expandedRowKeys.forEach(function (r, i) {
            if (r === rowKey) {
              _index = i;
            }
          });
          if (_index !== -1) {
            expandedRowKeys.splice(_index, 1);
            _this5.setState({ needRender: !needRender });
          }
        }
      }

      // expandState为true时，记录下
      _this.props.onExpand && _this.props.onExpand(expandState, record);

      if (_this5.treeType) {
        //收起和展开时，缓存 expandedKeys
        _this.cacheExpandedKeys = new Set(expandedRowKeys);
        //重新递归数据
        var flatTreeData = _this.deepTraversal(data);
        var sliceTreeList = flatTreeData.slice(_this.startIndex, _this.endIndex);
        _this.flatTreeData = flatTreeData;
        _this.handleTreeListChange(sliceTreeList);
        _this.cacheExpandedKeys = null;
      }
    };
  }, _temp;
}